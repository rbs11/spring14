// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "get_webpage.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

/* libcurl headers */
#include <curl/curl.h>

/* other misc headers */
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

/* our web cache implementation */
#include "web_cache.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::GTClientServerRPC;

class get_webpageHandler : virtual public get_webpageIf {
private:
    int32_t hit_count;
    int32_t total_count;
    int32_t hit_bytes_count;
    int32_t total_bytes_count;

public:
    get_webpageHandler() {
        /* initialize the web cache */
        init_web_cache(WEB_CACHE_SIZE);

        /* initialize all metric counters counters */
        hit_count = 0;
        total_count = 0;
        hit_bytes_count = 0;
        total_bytes_count = 0;
    }

    void ping() {
        // Your implementation goes here
        printf("ping\n");
    }

    struct wd_in {
        size_t size;
        size_t len;
        char *data;
    };

    /* This function is registered as a callback with CURL.  As the data
    from the requested webpage is returned in chunks, write_data is
    called with each chunk.  */
    static size_t write_data(void *buffer, size_t size, 
                         size_t nmemb, void *userp)
    {
        struct wd_in *wdi = (struct wd_in *)userp;

        while(wdi->len + (size * nmemb) >= wdi->size) {
            /* check for realloc failing in real code. */
            wdi->data = (char *)realloc(wdi->data, wdi->size*2);
            if (wdi->data == NULL) {
                error err;
                err.what = errno;
                err.why.assign(strerror(errno));
                throw err;
            }

            wdi->size*=2;
        }

        memcpy(wdi->data + wdi->len, buffer, size * nmemb);
        wdi->len+=size*nmemb;

        return size * nmemb;
    }

    void get_webpage_from_remote(webpage& _return, const std::string& url)
    {
        CURL *curl;
        CURLcode res;
        struct wd_in wdi;

#ifdef DEBUG
        std::cout << "get_webpage_from_remote" << std::endl;
        std::cout << "URL: " << url << std::endl;
#endif

        memset(&wdi, 0, sizeof(wdi));

        /* Get a curl handle.  Each thread will need a unique handle. */
        curl = curl_easy_init();

        if(NULL != curl) {
            wdi.size = 1024;

            /* Check for malloc failure in real code. */
            wdi.data = (char *)malloc(wdi.size);
            if (wdi.data == NULL) {
                fprintf(stderr, "Error: malloc could not allocate memory\n");
                error err;
                err.what = errno;
                err.why.assign(strerror(errno));
                throw err;
            }

            /* Set the URL for the operation. */
            curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

            /* "write_data" function to call with returned data. */
            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);

            /* userp parameter passed to write_data. */
            curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&wdi);

            /* Perform the actual query. */
            res = curl_easy_perform(curl);
            if(res != CURLE_OK) {
                fprintf(stderr, "Error: curl_easy_perform() failed: %s\n",
                        curl_easy_strerror(res));

                error err;
                err.what = res;
                err.why.assign(curl_easy_strerror(res));
                throw err;
            }

            /* Copy the content to client structure */
            _return.webpage_len = wdi.len;
            _return.webpage_data.assign(wdi.data);

            /* cleanup wdi.data buffer. */
            free(wdi.data);
        } else {
            fprintf(stderr, "Error: could not get CURL handle.\n");
            error err;
            err.what = -EINVAL;
            err.why.assign("cURL init failed. Try again");
            throw err;
        }
    }
#define DEBUG 1
    void get_webpage(webpage& _return, const std::string& url)
    {
#if DEBUG
        std::cout << "URL: " << url << std::endl;
#endif

        /*
         * First up check our local web cache to see if we have the web page
         * cached. If we do, then just return the cached contents to the
         * client.
         *
         * If we don't, then go to the remote webserver and fetch the webpage
         * using libcurl.
         */
        if (check_web_cache(url)) {
            get_webpage_from_cache(_return, url);
#if DEBUG
            std::cout << "webpage FOUND in cache(size: " <<
                _return.webpage_len << ")!" << std::endl;
#endif
            hit_count += 1;
            hit_bytes_count += _return.webpage_len;
        } else {
            /* get web page from remote server */
            get_webpage_from_remote(_return, url);

#if DEBUG
            std::cout << "webpage NOT found in cache (size: " <<
                _return.webpage_len << ")!" << std::endl;
#endif
            /* And also put the contents in the cache */
            put_webpage_to_cache(_return, url);
        }
        total_count += 1;
        total_bytes_count += _return.webpage_len;
    }

    void get_webcache_stats(cache_stat& _return) {
        _return.hit_count = hit_count;
        _return.total_count = total_count;
        _return.hit_bytes_count = hit_bytes_count;
        _return.total_bytes_count = total_bytes_count;
    }

    void reset_webcache_stats() {
        hit_count = 0;
        total_count = 0;
        hit_bytes_count = 0;
        total_bytes_count = 0;
    }
};

int main(int argc, char **argv) {
    int port = 9090;
    shared_ptr<get_webpageHandler> handler(new get_webpageHandler());
    shared_ptr<TProcessor> processor(new get_webpageProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    return 0;
}
